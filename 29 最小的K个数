题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

1、最大堆 O(nlogk)适合处理海量数据
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        if(input.empty()||k<=0||k>input.size()) return vector<int>();
        vector<int>res(input.begin(),input.begin()+k);
        make_heap(res.begin(),res.end(),less<int>());//最大堆
        for(int i=k;i<input.size();i++){
            if(input[i]<res[0]){//若小，把堆顶去掉，新数入堆
                pop_heap(res.begin(),res.end(),less<int>());
                res.pop_back();
                res.push_back(input[i]);
                push_heap(res.begin(),res.end(),less<int>());
            }
        }
        //sort_heap(res.begin(),res.end());//排序
        return res;
    }
};
2、最大堆 multiset（红黑树）实现
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(input.empty()||k<=0||k>input.size()) return res;
        multiset<int,greater<int>>LeastNumbers;//从大到小排序（允许重复排序）的multiset
        multiset<int,greater<int>>::iterator iterGreatest;//设置迭代器
        for(int i=0;i<input.size();i++){
            if(LeastNumbers.size()<k) LeastNumbers.insert(input[i]);
            else{
                iterGreatest=LeastNumbers.begin();
                if(input[i]<*iterGreatest){
                    LeastNumbers.erase(iterGreatest);
                    LeastNumbers.insert(input[i]);
                }
            }
        }
        for(iterGreatest=LeastNumbers.begin();iterGreatest!=LeastNumbers.end();iterGreatest++){
            res.push_back(*iterGreatest);
        }
        return res;
    }
};
//vector也可设置迭代器
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(input.empty()||k<=0||k>input.size()) return res;
        multiset<int,greater<int>>LeastNumbers;
        multiset<int,greater<int>>::iterator iterGreatest;
        vector<int>::iterator iterInput=input.begin();
        for(;iterInput!=input.end();iterInput++){
            if(LeastNumbers.size()<k) LeastNumbers.insert(*iterInput);
            else{
                iterGreatest=LeastNumbers.begin();
                if(*iterInput<*iterGreatest){
                    LeastNumbers.erase(iterGreatest);
                    LeastNumbers.insert(*iterInput);
                }
            }
        }
        for(iterGreatest=LeastNumbers.begin();iterGreatest!=LeastNumbers.end();iterGreatest++){
            res.push_back(*iterGreatest);
        }
        return res;
    }
};
3、最小堆 O(klogn)
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(input.empty()||k<=0||k>input.size()) return res;
        make_heap(input.begin(),input.end(),greater<int>());//建立最小堆
        for(int i=0;i<k;i++){//k次弹出堆顶，即最小的k个数字
            res.push_back(input[0]);
            pop_heap(input.begin(),input.end(),greater<int>());
            input.pop_back();
        }
        return res;
    }
}

4、Partition函数,O(n),但会修改原来数组
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(input.empty()||k<=0||k>input.size()) return res;
        int start=0,end=input.size()-1;
        int index=Partition(input,start,end);
        while(index!=k-1){//这里用k-1，表示index左边有k-1个，连上index共k个数。防止k=input.size()-1时出现异常
            if(index>k-1){
                end=index-1;
                index=Partition(input,start,end);
            }
            if(index<k-1){
                start=index+1;
                index=Partition(input,start,end);
            }
        }
        for(int i=0;i<k;i++) res.push_back(input[i]);
        return res;
    }
    int Partition(vector<int> &input, int start, int end){
        int small=start-1;
        for(int i=start;i<end;i++){
            if(input[i]<input[end]){
                small++;
                if(small!=i) swap(input[small],input[i]);
            }
        }
        small++;
        swap(input[small],input[end]);
        return small;
    }
};
