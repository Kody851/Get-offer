P96
题目描述：
给定一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]* k[1] * … *k[m]可能的最大乘积是多少？
例如：当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
原文：https://blog.csdn.net/weixin_32087115/article/details/87623493 
题目解析：
该题目是典型的动态规划题目，即求最优解。整体问题的最优解依赖于子问题的最优解，子问题之间还有相互重叠的更小的子问题，
为避免子问题的重复计算，我们使用数组将子问题的最优解存储起来。
从上往下分析问题：
假设我们想求绳子长度为8时的最优解(下面最优解用f(n)表示，n为绳子的长度)，问题可分解为f(7)和f(1)，或者f(6)和f(2)，或者f(5)和f(3)，或者f(4)和f(4)。
当然，这是我们剪的第一刀，一刀两段，前面所述的f(n)(n < 8)就是我们进一步需要探讨的子问题，要得到f(8)，我们必须得到最优的f(1……7)，要得到f(7)，
就必须要得到f(1……6)，这样依次类推下去，就是直观意义上的动态规划问题。
从下到上解决问题：
既然我们知道要使用子问题的最优解去解决父问题的最优解，结合题目我们需要先存储几个子问题的最优解，题目给出m>1,n>1。
1.因此，在绳子长度小于2时，最大乘积设为0
2.绳子长度等于2时，只能剪一刀，最大乘积为1*1 = 1，即f(2) = 1
3.绳子长度等于3时，最大乘积为1*2 = 2
4.当绳子长度大于等于4时，就需要使用子问题来解决了。
插入一句：绳子长度小于等于3时，所求的最优解是根据题目的前提条件求得，因为必须要切一刀，所以最大乘积是在切完这一刀的前提下求得的，
事实上，切完所求得的乘积并没有不切的时候大，例如f(3) = 2，但是3要大于2；为了使长度大于等于4的时候得到子问题的最大乘积，
因此使用一个product数组存放子问题的最优解。
int maxProductAfterCutting(int len){
    if(len<2) return 0;
    if(len==2) return 1;
    if(len==3) return 2;
    vector<int>dp(len+1);
    dp[0]=0;
    dp[1]=1;
    dp[2]=2;
    dp[3]=3;
    int max=0;
    for(int i=4;i<=len;i++){
        max=0;
        for(int j=1;j<=i/2;j++){
            int product=dp[j]*dp[i-j];
            if(max<product) max=product;
            dp[i]=max;
        }
    }
    return dp[len];
}
